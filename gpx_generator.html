<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPX è·¯å¾‘ç”Ÿæˆå™¨ Pro - è‡è‡å®…é…ç¶²</title>
    <link rel="icon" href="./mashroom_s.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* ä¿®æ­£ 1: ç§»é™¤ body çš„ touch-action: none */
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; background-color: #111827; color: #d1d5db; overflow: hidden; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        .map-control-group {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 9999px;
            padding: 4px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            z-index: 100; pointer-events: auto;
        }
        .map-btn {
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; font-weight: bold; color: #374151;
            transition: all 0.2s; border-radius: 9999px;
            cursor: pointer; -webkit-tap-highlight-color: transparent;
        }
        .map-btn:hover { background-color: #e5e7eb; }
        .map-btn:active { background-color: #d1d5db; transform: scale(0.95); }
        .divider { height: 1px; background-color: #e5e7eb; margin: 2px 8px; }

        /* æµ®å‹•æ“ä½œå€ (FAB) */
        .quick-actions {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px;
            background: rgba(31, 41, 55, 0.9);
            padding: 8px 12px; border-radius: 9999px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 90; opacity: 0; pointer-events: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px); border: 1px solid #4b5563;
        }
        .quick-actions.show { opacity: 1; pointer-events: auto; }
        .fab-btn {
            color: white; font-size: 12px; font-weight: bold;
            padding: 6px 12px; border-radius: 20px; border: none; cursor: pointer; white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background 0.2s; display: block;
            -webkit-tap-highlight-color: transparent;
        }
        .fab-btn:active { transform: scale(0.95); }
        .fab-btn.hidden { display: none; }
        
        #coords-display {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.9); color: #374151;
            padding: 4px 8px; font-size: 12px; border-radius: 4px;
            pointer-events: none; z-index: 50; backdrop-filter: blur(2px);
            border: 1px solid #e5e7eb;
        }

        /* ä¿®æ­£ 2: èª¿æ•´æç¤ºæ¡†ä½ç½®ç‚ºé ä¸Šç½®ä¸­ (top: 30px) */
        #toast-message {
            position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
            background-color: rgba(245, 158, 11, 0.95); color: white;
            padding: 10px 20px; border-radius: 20px; font-size: 14px; font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2); z-index: 200;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #toast-message.show { opacity: 1; }

        #sidebar { transition: transform 0.3s ease-in-out; }
        .sidebar-overlay { backdrop-filter: blur(2px); }
        #app-content { display: none; }

        .top-left-actions {
            position: absolute; top: 1rem; left: 1rem; z-index: 60;
            display: flex; gap: 10px;
        }
        .action-btn {
            background: white; color: #1f2937;
            padding: 8px 12px; border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            font-size: 20px; font-weight: bold;
            cursor: pointer; transition: transform 0.1s;
            display: flex; align-items: center; justify-content: center;
            width: 44px; height: 44px;
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn.blue { background-color: #3b82f6; color: white; }
        .action-btn.purple { background-color: #8b5cf6; color: white; }

        /* ä¿®æ­£ 3: åƒ…é‡å°åœ°åœ–å€åŸŸç¦æ­¢é è¨­è§¸æ§è¡Œç‚º */
        #mainView { touch-action: none; }

        @media (max-width: 768px) {
            .quick-actions { top: 80px; }
            /* æ‰‹æ©Ÿç‰ˆ Toast ç¨å¾®å¾€ä¸‹é¿é–‹æ¼¢å ¡é¸å–® */
            #toast-message { top: 80px; }
        }
    </style>
</head>
<body class="flex h-screen w-screen">

    <script>
        const SUPABASE_URL = 'https://htdddmoclmhqebyvzean.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_95x4eVN3GHlRFfnJQHaXpg_csrMp2fJ';
        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        async function checkAuth() {
            try {
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (!session) {
                    alert('è«‹å…ˆç™»å…¥æ‰èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½ï¼');
                    try { window.location.replace('./index.html'); } 
                    catch (e) { document.body.innerHTML = '<div class="flex items-center justify-center h-screen w-screen bg-gray-900 text-white text-xl">è«‹å…ˆç™»å…¥</div>'; }
                } else {
                    document.getElementById('app-content').style.display = 'flex';
                    setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
                }
            } catch (error) { 
                console.error("Auth Error:", error);
                alert("é©—è­‰ä¼ºæœå™¨é€£ç·šç•°å¸¸ï¼Œè«‹æª¢æŸ¥ç¶²è·¯æˆ–æ˜¯é‡æ–°æ•´ç†é é¢ã€‚");
             }
        }
        checkAuth();
    </script>

    <!-- æµ®å‹•æç¤º -->
    <div id="toast-message">è«‹é»æ“Šå¦ä¸€æœµèŠ±é€²è¡Œäº¤æ›</div>

    <div id="app-content" class="w-full h-full flex">
        
        <div class="top-left-actions">
            <button id="hamburger-btn" class="action-btn md:hidden" onclick="toggleSidebar()">â˜°</button>
            <button id="quick-redraw-btn" class="action-btn blue hidden" onclick="optimizeRoute()" title="å¿«é€Ÿé‡ç¹ª (AIåˆ†æ)">â†»</button>
            <button id="quick-mode-btn" class="action-btn purple hidden" onclick="quickToggleMode()" title="åˆ‡æ› æ”¶æœ/ç¨®èŠ± æ¨¡å¼">ğŸ“</button>
        </div>

        <div id="sidebar-overlay" class="sidebar-overlay fixed inset-0 bg-black/50 z-[55] hidden md:hidden" onclick="toggleSidebar()"></div>

        <aside id="sidebar" class="fixed md:relative w-[85%] md:w-96 h-full bg-gray-800 border-r border-gray-700 flex flex-col z-[70] transform -translate-x-full md:translate-x-0 shadow-2xl md:shadow-none">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-900">
                <div>
                    <h1 class="text-xl font-bold text-white">è·¯å¾‘ç”Ÿæˆå™¨ Pro</h1>
                    <div class="text-xs text-green-400 mt-1">â— æ¬Šé™é©—è­‰é€šé</div>
                </div>
                <button class="md:hidden text-gray-400 text-2xl px-2" onclick="toggleSidebar()">&times;</button>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-6">
                <div class="space-y-3">
                    <h2 class="text-sm font-bold text-indigo-400 uppercase tracking-wider border-b border-gray-700 pb-1">1. ç™»éŒ„è·¯å¾‘è³‡è¨Š</h2>
                    <div>
                        <label class="block text-xs font-medium text-gray-400 mb-1">è·¯å¾‘åç¨±</label>
                        <input type="text" id="route-name" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm text-white placeholder-gray-500 placeholder-opacity-50 focus:border-green-500 focus:outline-none" placeholder="ä¾‹å¦‚ï¼šå¤§å®‰æ£®æ—å…¬åœ’">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-400 mb-1">å·¨å¤§èŠ±åº§æ¨™ (ç·¯åº¦, ç¶“åº¦)</label>
                        <textarea id="rawInputData" class="w-full h-24 bg-gray-900 border border-gray-600 rounded p-2 text-xs font-mono text-green-300 placeholder-gray-500 placeholder-opacity-50 focus:border-green-500 focus:outline-none resize-y" placeholder="è«‹è²¼ä¸Šåº§æ¨™ï¼Œæ ¼å¼ç¯„ä¾‹ï¼š&#10;-0.5715520, 117.2818990&#10;-0.5711250, 117.2815350"></textarea>
                    </div>
                    <div class="mt-2">
                        <input type="file" id="gpxFileInput" accept=".gpx" class="hidden" multiple onchange="handleGPXUpload(this)">
                        <button onclick="document.getElementById('gpxFileInput').click()" class="w-full bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-2 px-4 rounded text-sm transition border border-gray-500 border-dashed flex items-center justify-center gap-2">
                            <span>ğŸ“‚</span> ä¸Šå‚³å¤šå€‹ GPX (è‡ªå‹•éæ¿¾é‡è¦†)
                        </button>
                    </div>

                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="drawDirectRoute()" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded text-sm transition shadow hover:scale-[1.02]">
                            ç¹ªè£½ (ä¾åº)
                        </button>
                        <button onclick="optimizeRoute()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded text-sm transition shadow hover:scale-[1.02]">
                            AI ç¹ªè£½ â†»
                        </button>
                    </div>
                    <div id="sort-stats" class="text-xs text-gray-500 text-center hidden"></div>
                </div>

                <div class="space-y-4">
                    <div class="flex justify-between items-end border-b border-gray-700 pb-1">
                        <h2 class="text-sm font-bold text-indigo-400 uppercase tracking-wider">2. è·¯å¾‘æ¨¡å¼</h2>
                        <div class="flex items-center">
                            <!-- ä¿®æ­£ 4: Toggle Switch çµæ§‹ï¼ŒåŠ å…¥ peer å’Œ peer-checked -->
                            <label for="path-toggle" class="flex items-center cursor-pointer select-none">
                                <div class="relative">
                                    <input type="checkbox" id="path-toggle" class="sr-only peer">
                                    <div class="block bg-gray-600 w-10 h-6 rounded-full peer-checked:bg-green-500 transition-colors"></div>
                                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-full"></div>
                                </div>
                                <span id="mode-label" class="ml-2 text-xs font-bold text-gray-300">ç›´é€£æ¨¡å¼</span>
                            </label>
                        </div>
                    </div>

                    <div id="mode-indicator" class="hidden text-xs text-center p-2 rounded bg-indigo-900/50 text-indigo-200 border border-indigo-700/50">å…¨åŸŸè¨­å®šæ¨¡å¼</div>
                    
                    <div id="local-edit-btns" class="hidden grid grid-cols-3 gap-2">
                        <button onclick="resetCurrentFlower()" class="bg-red-600 hover:bg-red-700 text-white py-1 px-2 rounded text-xs font-bold shadow transition hover:scale-105">é‡ç½®</button>
                        <button onclick="mirrorCurrentFlower()" class="bg-blue-600 hover:bg-blue-700 text-white py-1 px-2 rounded text-xs font-bold shadow transition hover:scale-105">é¡åƒ â‡„</button>
                        <button onclick="initiateSwap()" class="bg-orange-500 hover:bg-orange-600 text-white py-1 px-2 rounded text-xs font-bold shadow transition hover:scale-105">äº¤æ› â‡…</button>
                    </div>
                    
                    <div id="swap-hint" class="hidden text-xs text-center p-2 rounded bg-orange-900/50 text-orange-200 border border-orange-700/50 animate-pulse">
                        è«‹é»æ“Šå¦ä¸€æœµèŠ±é€²è¡Œäº¤æ›
                    </div>

                    <div id="flower-params" class="space-y-3 opacity-50 pointer-events-none transition-opacity duration-300">
                        <div>
                            <div class="flex justify-between text-xs mb-1"><span class="text-gray-400">å…¥å£åè§’</span><span id="val-entryAng" class="text-blue-400 font-bold">300Â°</span></div>
                            <input type="range" id="entryAngle" min="0" max="360" value="300" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer" oninput="onParamChange('entryAng', this.value)">
                        </div>
                        <div>
                            <div class="flex justify-between text-xs mb-1"><span class="text-gray-400">ç©¿å¿ƒåè§’</span><span id="val-apexAng" class="text-blue-400 font-bold">300Â°</span></div>
                            <input type="range" id="apexAngle" min="0" max="360" value="300" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer" oninput="onParamChange('apexAng', this.value)">
                        </div>
                        <div>
                            <div class="flex justify-between text-xs mb-1"><span class="text-gray-400">å´é»åè§’</span><span id="val-sideAng" class="text-blue-400 font-bold">120Â°</span></div>
                            <input type="range" id="sideAngle" min="0" max="360" value="120" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer" oninput="onParamChange('sideAng', this.value)">
                        </div>
                        <div>
                            <div class="flex justify-between text-xs mb-1"><span class="text-gray-400">å‡ºå£åè§’</span><span id="val-exitAng" class="text-blue-400 font-bold">20Â°</span></div>
                            <input type="range" id="exitAngle" min="0" max="360" value="20" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer" oninput="onParamChange('exitAng', this.value)">
                        </div>
                    </div>
                </div>

                <div class="space-y-3 pb-8">
                    <h2 class="text-sm font-bold text-indigo-400 uppercase tracking-wider border-b border-gray-700 pb-1">3. ç¨®èŠ±è·¯å¾‘ç”Ÿæˆ</h2>
                    <div class="grid grid-cols-1 gap-3">
                        <button onclick="generateGPX('Router')" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded shadow-lg transform transition hover:scale-[1.02]">ç”Ÿæˆ Router è·¯å¾‘</button>
                        <button onclick="generateGPX('Joystick')" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded shadow-lg transform transition hover:scale-[1.02]">ç”Ÿæˆ Joystick è·¯å¾‘</button>
                    </div>
                    <div id="statsBox" class="bg-gray-700/50 p-3 rounded text-xs text-gray-400 border border-gray-600 leading-relaxed">å°šæœªæœ‰è·¯å¾‘è³‡è¨Š...</div>
                </div>
            </div>
        </aside>

        <main class="flex-1 relative bg-gray-900 cursor-grab active:cursor-grabbing overflow-hidden" id="mainView">
            <canvas id="mapCanvas" class="block w-full h-full"></canvas>
            
            <div class="map-control-group">
                <button onclick="fitToScreen()" class="map-btn text-[10px] font-black" title="é©æ‡‰è¦–çª—">All</button>
                <div class="divider"></div>
                <button onclick="zoomStep(1.2)" class="map-btn" title="æ”¾å¤§">ï¼‹</button>
                <div class="divider"></div>
                <button onclick="zoomStep(0.833)" class="map-btn" title="ç¸®å°">ï¼</button>
            </div>

            <!-- æµ®å‹•æ“ä½œå€ (FAB) -->
            <div id="floating-actions" class="quick-actions">
                <button id="fab-reset" onclick="resetCurrentFlower()" class="fab-btn bg-red-600 hover:bg-red-500">é‡ç½®</button>
                <button id="fab-mirror" onclick="mirrorCurrentFlower()" class="fab-btn bg-blue-600 hover:bg-blue-500">é¡åƒ</button>
                <button id="fab-swap" onclick="initiateSwap()" class="fab-btn bg-orange-500 hover:bg-orange-400">äº¤æ›</button>
                <button id="fab-delete" onclick="deleteCurrentFlower()" class="fab-btn bg-gray-600 hover:bg-gray-500">åˆªé™¤</button>
            </div>

            <div id="coords-display">Lat: -, Lon: -</div>
        </main>
    </div>

    <script>
        let centers = [];
        let pathPoints = [];
        let canvas, ctx;
        
        const FIXED_ALGO_DIST = 30;
        const FIXED_ENTRY_DIST = 1.1;
        const FIXED_CROSS_FACTOR = 1.1;
        const FIXED_SIDE_DIST = 1.1;
        const METERS_PER_DEGREE = 111320; 

        let isFlowerPathMode = false;
        let selectedIndex = -1;
        let swapSourceIndex = -1; 
        let optimizationIteration = 0; 
        
        let globalParams = { entryAngle: 300, apexAngle: 300, sideAngle: 120, exitAngle: 20 };
        let flowerOverrides = {}; 

        let scale = 10000;
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let isDraggingNode = false;
        let draggingNodeIndex = -1;
        let lastMouseX, lastMouseY;
        let clickStartX, clickStartY;
        let startNode = null;
        let endNode = null;
        let isDraggingStart = false;
        let isDraggingEnd = false;
        
        // è¢å¹•åº§æ¨™è½‰ç¶“ç·¯åº¦ (ç”¨æ–¼æ‹–æ›³èµ·çµ‚é»)
        function screenToLatLon(x, y) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const base = centers.length > 0 ? centers[0] : {lat:0, lon:0};
            
            // åæ¨å…¬å¼
            const dx = (x - offsetX - cx) * 100 / scale;
            const dy = -(y - offsetY - cy) * 100 / scale; // yè»¸åè½‰
            
            const lat = base.lat + dy / METERS_PER_DEGREE;
            const lon = base.lon + dx / METERS_PER_DEGREE;
            
            return { lat, lon };
        }
        
        window.onload = function() {
            canvas = document.getElementById('mapCanvas');
            ctx = canvas.getContext('2d');
            
            // --- [æ–°å¢] ä¿®æ­£ 2: é˜»æ­¢å´é‚Šæ¬„äº‹ä»¶ç©¿é€åˆ°åœ°åœ– ---
            // é€™æ®µç¨‹å¼ç¢¼ç¢ºä¿åœ¨å´é‚Šæ¬„æ»‘å‹•æ™‚ï¼Œä¸æœƒèª¤è§¸åˆ°åº•ä¸‹çš„åœ°åœ–
            const sidebar = document.getElementById('sidebar');
            ['touchstart', 'touchmove', 'touchend', 'mousedown', 'mousemove', 'mouseup', 'wheel'].forEach(evt => {
                sidebar.addEventListener(evt, (e) => e.stopPropagation(), { passive: false });
            });
            // ----------------------------------------------

            const rawInput = document.getElementById('rawInputData');
            rawInput.addEventListener('change', () => cleanInputData());
            
            const view = document.getElementById('mainView');
            view.addEventListener('mousedown', onMouseDown);
            view.addEventListener('mousemove', onMouseMove);
            view.addEventListener('mouseup', onMouseUp);
            view.addEventListener('wheel', onWheel);
            view.addEventListener('click', onCanvasClick);
            view.addEventListener('touchstart', onTouchStart, { passive: false });
            view.addEventListener('touchmove', onTouchMove, { passive: false });
            view.addEventListener('touchend', onTouchEnd);

            window.addEventListener('resize', resizeCanvas);

            const toggle = document.getElementById('path-toggle');
            toggle.addEventListener('change', function() {
                isFlowerPathMode = this.checked;
                onModeToggle();
            });

            resizeCanvas();
            centerMap();

            if (window.innerWidth <= 768) {
                const sb = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                if (!sb.classList.contains('open')) {
                    sb.classList.remove('-translate-x-full');
                    overlay.classList.remove('hidden');
                }
            }
        };

        function cleanInputData() {
            const raw = document.getElementById('rawInputData').value;
            if (!raw) return;
            const matches = raw.matchAll(/(-?\d+(\.\d+)?)[,\s]+(-?\d+(\.\d+)?)/g);
            let cleaned = "";
            for (const match of matches) {
                cleaned += `${match[1]}, ${match[3]}\n`;
            }
            if (cleaned) {
                document.getElementById('rawInputData').value = cleaned.trim();
            }
        }

        // è™•ç† GPX ä¸Šå‚³èˆ‡è§£æ
        async function handleGPXUpload(input) {
            const files = Array.from(input.files);
            if (files.length === 0) return;

            // å®šç¾©è®€å–å–®ä¸€æª”æ¡ˆçš„ Promise å‡½å¼
            const readFile = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve({ name: file.name, content: e.target.result });
                reader.onerror = (e) => reject(e);
                reader.readAsText(file);
            });

            try {
                // å¹³è¡Œè®€å–æ‰€æœ‰æª”æ¡ˆ
                const results = await Promise.all(files.map(readFile));
                const parser = new DOMParser();
                
                // --- æƒ…å¢ƒ Aï¼šå–®ä¸€æª”æ¡ˆ (å˜—è©¦é‚„åŸå°ˆæ¡ˆæ¨¡å¼) ---
                if (results.length === 1) {
                    const xmlDoc = parser.parseFromString(results[0].content, "text/xml");
                    const descTags = xmlDoc.getElementsByTagName("desc");
                    
                    for (let i = 0; i < descTags.length; i++) {
                        try {
                            const jsonStr = descTags[i].textContent;
                            if (jsonStr.includes("MushroomLabProject")) {
                                const data = JSON.parse(jsonStr);
                                if (confirm(`åµæ¸¬åˆ°ã€Œ${results[0].name}ã€åŒ…å«å®Œæ•´å°ˆæ¡ˆæ•¸æ“šï¼\n\næŒ‰ã€Œç¢ºå®šã€ï¼šé‚„åŸèŠ±æœµä¸­å¿ƒèˆ‡è¨­å®šã€‚\næŒ‰ã€Œå–æ¶ˆã€ï¼šåƒ…è®€å–åº§æ¨™ã€‚`)) {
                                    // åŸ·è¡Œé‚„åŸé‚è¼¯
                                    centers = data.centers || [];
                                    flowerOverrides = data.overrides || {};
                                    selectedIndex = -1;
                                    swapSourceIndex = -1;
                                    startNode = null;
                                    endNode = null;
                                    isFlowerPathMode = data.isFlower || false;
                                    document.getElementById('path-toggle').checked = isFlowerPathMode;
                                    
                                    checkAndFixGeometry(centers);
                                    updatePathData();
                                    updateUIForMode();
                                    draw();
                                    resizeCanvas();
                                    setTimeout(fitToScreen, 100);
                                    
                                    alert(`å°ˆæ¡ˆé‚„åŸæˆåŠŸï¼å·²è¼‰å…¥ ${centers.length} é»ã€‚`);
                                    input.value = '';
                                    return;
                                }
                            }
                        } catch (e) { console.log("JSON parse error", e); }
                    }
                }

                // --- æƒ…å¢ƒ Bï¼šå¤šæª”æˆ–å–®æª” (ç´”åº§æ¨™åˆä½µæ¨¡å¼) ---
                let combinedPoints = new Set(); // ä½¿ç”¨ Set è‡ªå‹•éæ¿¾é‡è¤‡å­—ä¸²
                let totalFiles = 0;
                let totalPointsFound = 0;

                results.forEach(fileResult => {
                    const xmlDoc = parser.parseFromString(fileResult.content, "text/xml");
                    const trkpts = xmlDoc.getElementsByTagName("trkpt");
                    const rtepts = xmlDoc.getElementsByTagName("rtept");
                    const wpts = xmlDoc.getElementsByTagName("wpt");

                    let pointsInFile = 0;
                    const extract = (nodes) => {
                        for (let i = 0; i < nodes.length; i++) {
                            const lat = nodes[i].getAttribute("lat");
                            const lon = nodes[i].getAttribute("lon");
                            if (lat && lon) {
                                // æ ¼å¼åŒ–ç‚ºå­—ä¸²å­˜å…¥ Setï¼Œé‡è¤‡çš„æœƒè¢«è‡ªå‹•å¿½ç•¥
                                combinedPoints.add(`${lat}, ${lon}`);
                                pointsInFile++;
                            }
                        }
                    };

                    extract(trkpts);
                    extract(rtepts);
                    extract(wpts);

                    if (pointsInFile > 0) {
                        totalFiles++;
                        totalPointsFound += pointsInFile;
                    }
                });

                if (combinedPoints.size === 0) {
                    alert("åœ¨é¸å–çš„æª”æ¡ˆä¸­æ‰¾ä¸åˆ°ä»»ä½•åº§æ¨™æ•¸æ“šã€‚");
                    input.value = '';
                    return;
                }

                // å°‡ Set è½‰å›é™£åˆ—ä¸¦å¡«å…¥ Textarea
                const finalPointsArray = Array.from(combinedPoints);
                const rawInput = document.getElementById('rawInputData');
                rawInput.value = finalPointsArray.join('\n');

                const duplicateCount = totalPointsFound - combinedPoints.size;
                alert(`æ‰¹æ¬¡è¼‰å…¥å®Œæˆï¼\n\n- ä¾†æºæª”æ¡ˆï¼š${results.length} å€‹\n- åŸå§‹é»æ•¸ï¼š${totalPointsFound}\n- éæ¿¾é‡è¤‡ï¼š${duplicateCount}\n- å¯¦éš›è¼‰å…¥ï¼š${combinedPoints.size}\n\nè«‹é»æ“Šã€Œç¹ªè£½ã€æˆ–ã€ŒAI ç¹ªè£½ã€ç¹¼çºŒã€‚`);
                
                input.value = '';

            } catch (err) {
                console.error(err);
                alert("è®€å–æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼ã€‚");
                input.value = '';
            }
        }

        function resizeCanvas() {
            const view = document.getElementById('mainView');
            canvas.width = view.clientWidth;
            canvas.height = view.clientHeight;
            draw();
        }

        function onModeToggle() {
            const label = document.getElementById('mode-label');
            const paramDiv = document.getElementById('flower-params');
            const indicator = document.getElementById('mode-indicator');
            const toggleDot = document.querySelector('.dot');
            const quickBtn = document.getElementById('quick-mode-btn');
            
            if (isFlowerPathMode) {
                label.innerText = "ç¨®èŠ±æ¨¡å¼";
                label.classList.replace('text-gray-300', 'text-green-400');
                paramDiv.classList.remove('opacity-50', 'pointer-events-none');
                indicator.classList.remove('hidden');
                toggleDot.style.transform = 'translateX(100%)';
                quickBtn.innerText = 'ğŸŒ¸';
                quickBtn.classList.remove('bg-gray-600');
                quickBtn.classList.add('purple');
            } else {
                label.innerText = "ç›´é€£æ¨¡å¼";
                label.classList.replace('text-green-400', 'text-gray-300');
                paramDiv.classList.add('opacity-50', 'pointer-events-none');
                indicator.classList.add('hidden');
                document.getElementById('local-edit-btns').classList.add('hidden');
                document.getElementById('swap-hint').classList.add('hidden');
                selectedIndex = -1; 
                swapSourceIndex = -1;
                toggleDot.style.transform = 'translateX(0)';
                quickBtn.innerText = 'ğŸ“';
                quickBtn.classList.remove('purple');
                quickBtn.classList.add('bg-gray-600');
            }
            document.getElementById('path-toggle').checked = isFlowerPathMode;
            updatePathData(); 
            updateUIForMode(); 
            draw();
        }

        function quickToggleMode() {
            isFlowerPathMode = !isFlowerPathMode;
            onModeToggle();
        }

        function drawDirectRoute() {
            cleanInputData();
            const rawText = document.getElementById('rawInputData').value;
            let points = parseTextToPoints(rawText);
            
            if (points.length < 2) { 
                if (rawText.trim() === '') alert("è«‹è²¼ä¸Šåº§æ¨™è³‡æ–™");
                else alert("è«‹è‡³å°‘è¼¸å…¥ 2 å€‹æœ‰æ•ˆçš„åº§æ¨™é»"); 
                return; 
            }

            const uniquePoints = [];
            points.forEach(p => {
                let isDuplicate = false;
                for (const existing of uniquePoints) {
                    if (getDistanceMeters(p, existing) < 0.5) { isDuplicate = true; break; }
                }
                if (!isDuplicate) uniquePoints.push(p);
            });
            
            centers = uniquePoints;
            flowerOverrides = {}; 
            selectedIndex = -1;
            swapSourceIndex = -1;
            // é‡ç½®èµ·çµ‚é»ï¼Œè®“ updatePathData é‡æ–°è¨ˆç®—é è¨­ä½ç½®
            startNode = null;
            endNode = null;
            
            document.getElementById('sort-stats').innerText = `å·²è¼‰å…¥ ${uniquePoints.length} é» (ä¾ç…§åŸå§‹é †åº)ã€‚`;
            document.getElementById('sort-stats').classList.remove('hidden');

            checkAndFixGeometry(centers);
            updatePathData();
            resizeCanvas();
            setTimeout(() => {
                fitToScreen();
                if (window.innerWidth <= 768) closeSidebar();
            }, 100);
            updateUIForMode(); 
        }

        function optimizeRoute() {
            cleanInputData();
            const rawText = document.getElementById('rawInputData').value;
            let points = parseTextToPoints(rawText);
            
            if (points.length < 2) { 
                if (rawText.trim() === '') alert("è«‹è²¼ä¸Šåº§æ¨™è³‡æ–™");
                else alert("è«‹è‡³å°‘è¼¸å…¥ 2 å€‹æœ‰æ•ˆçš„åº§æ¨™é»"); 
                return; 
            }

            const uniquePoints = [];
            points.forEach(p => {
                let isDuplicate = false;
                for (const existing of uniquePoints) {
                    if (getDistanceMeters(p, existing) < 0.5) { isDuplicate = true; break; }
                }
                if (!isDuplicate) uniquePoints.push(p);
            });
            const originalCount = points.length;
            points = uniquePoints;

            let sumLat = 0, sumLon = 0;
            points.forEach(p => { sumLat += p.lat; sumLon += p.lon; });
            const center = { lat: sumLat/points.length, lon: sumLon/points.length };
            let candidates = points.map((p, idx) => ({ index: idx, dist: getDistanceMeters(p, center) })).sort((a, b) => b.dist - a.dist);
            let candidateLimit = Math.min(5, candidates.length);
            let startOriginalIndex = candidates[optimizationIteration % candidateLimit].index;
            optimizationIteration++;

            const sorted = [];
            const visited = new Set();
            let currIdx = startOriginalIndex;
            sorted.push(points[currIdx]);
            visited.add(currIdx);

            while (sorted.length < points.length) {
                let nearestIdx = -1;
                let minDist = Infinity;
                const currPoint = points[currIdx];
                for (let i = 0; i < points.length; i++) {
                    if (visited.has(i)) continue;
                    const d = getDistanceMeters(currPoint, points[i]);
                    if (d < minDist) { minDist = d; nearestIdx = i; }
                }
                if (nearestIdx !== -1) {
                    visited.add(nearestIdx);
                    sorted.push(points[nearestIdx]);
                    currIdx = nearestIdx;
                } else break;
            }

            centers = applyTwoOpt(sorted);
            flowerOverrides = {}; 
            selectedIndex = -1;
            swapSourceIndex = -1;
            
            document.getElementById('sort-stats').innerText = `å»é™¤é‡è¤‡ ${originalCount - points.length} é»ï¼Œå…± ${points.length} é»ã€‚`;
            document.getElementById('sort-stats').classList.remove('hidden');

            checkAndFixGeometry(centers);
            updatePathData();
            resizeCanvas();
            setTimeout(() => {
                fitToScreen();
                if (window.innerWidth <= 768) closeSidebar();
            }, 100);
            updateUIForMode(); 
        }

        function applyTwoOpt(route) {
            let newRoute = [...route];
            let improved = true;
            let iterations = 0;
            const maxIterations = 50; 
            while (improved && iterations < maxIterations) {
                improved = false;
                iterations++;
                for (let i = 0; i < newRoute.length - 2; i++) {
                    for (let j = i + 2; j < newRoute.length - 1; j++) {
                        const d1 = getDistanceMeters(newRoute[i], newRoute[i+1]);
                        const d2 = getDistanceMeters(newRoute[j], newRoute[j+1]);
                        const d3 = getDistanceMeters(newRoute[i], newRoute[j]);
                        const d4 = getDistanceMeters(newRoute[i+1], newRoute[j+1]);
                        if (d1 + d2 > d3 + d4 + 0.001) {
                            const reversedSegment = newRoute.slice(i + 1, j + 1).reverse();
                            newRoute.splice(i + 1, reversedSegment.length, ...reversedSegment);
                            improved = true;
                        }
                    }
                }
            }
            return newRoute;
        }

        function checkAndFixGeometry(sortedCenters) {
            for (let i = 0; i < sortedCenters.length; i++) {
                // å¦‚æœé€™å€‹é»å·²ç¶“æœ‰æ‰‹å‹•(æˆ–ä¹‹å‰è‡ªå‹•)è¨­å®šçš„åƒæ•¸ï¼Œå°±è·³éï¼Œé¿å…é‡è¤‡ç¿»è½‰
                if (flowerOverrides[i]) continue;

                const curr = sortedCenters[i];
                const prev = (i === 0) ? sortedCenters[sortedCenters.length-1] : sortedCenters[i-1];
                const next = (i === sortedCenters.length - 1) ? sortedCenters[0] : sortedCenters[i+1];
                const angleFromPrev = getBearing(prev, curr);
                const angleToNext = getBearing(curr, next);
                
                // è¨ˆç®—è½‰è§’
                let turnAngle = (angleToNext - angleFromPrev + 540) % 360 - 180;
                let sideBias = (globalParams.sideAngle > 180) ? globalParams.sideAngle - 360 : globalParams.sideAngle;
                
                // åˆ¤æ–·æ˜¯å¦éœ€è¦ç¿»è½‰ (åƒ…é‡å°æ²’æœ‰è¨­å®šéçš„æ–°é»)
                if ((turnAngle > 0 && sideBias > 0) || (turnAngle < 0 && sideBias < 0)) {
                    flowerOverrides[i] = { ...globalParams };
                    const p = flowerOverrides[i];
                    p.entryAngle = (360 - p.entryAngle) % 360;
                    p.apexAngle = (360 - p.apexAngle) % 360;
                    p.sideAngle = (360 - p.sideAngle) % 360;
                    p.exitAngle = (360 - p.exitAngle) % 360;
                }
            }
        }

        function updatePathData() {
            if (centers.length < 2) return;
            
            let flowerPath = [];
            if (isFlowerPathMode) flowerPath = generatePathAlgorithm(centers);
            else flowerPath = [...centers];

            // --- [æ–°å¢] èµ·é»èˆ‡çµ‚é»çš„åˆå§‹åŒ–é‚è¼¯ ---
            if (isFlowerPathMode && flowerPath.length > 0) {
                // å¦‚æœé‚„æ²’æœ‰èµ·é»ï¼Œæ ¹æ“šç¬¬ä¸€é»çš„é€²å…¥è§’åº¦å¾€å¤–æ¨ 20ç±³
                if (!startNode) {
                    const firstP = flowerPath[0];
                    const secondP = flowerPath[1]; // ç”¨ä¾†æŠ“è§’åº¦
                    const angle = getBearing(secondP, firstP); // åå‘å»¶ä¼¸
                    startNode = getOffsetPoint(firstP, 20, angle);
                }
                // å¦‚æœé‚„æ²’æœ‰çµ‚é»ï¼Œæ ¹æ“šæœ€å¾Œä¸€é»çš„å‡ºå£è§’åº¦å¾€å¤–æ¨ 20ç±³
                if (!endNode) {
                    const lastP = flowerPath[flowerPath.length - 1];
                    const prevP = flowerPath[flowerPath.length - 2];
                    const angle = getBearing(prevP, lastP); // æ­£å‘å»¶ä¼¸
                    endNode = getOffsetPoint(lastP, 20, angle);
                }
                // çµ„è£ï¼šèµ·é» + èŠ±æœµè·¯å¾‘ + çµ‚é»
                pathPoints = [startNode, ...flowerPath, endNode];
            } else {
                // ç›´é€£æ¨¡å¼æˆ–ç„¡è³‡æ–™ï¼Œä¿æŒåŸæ¨£ (æˆ–æ˜¯æ‚¨ä¹Ÿæƒ³åœ¨ç›´é€£æ¨¡å¼åŠ èµ·çµ‚é»? ç›®å‰å…ˆåªé‡å°ç¨®èŠ±æ¨¡å¼)
                pathPoints = [...flowerPath];
                startNode = null; 
                endNode = null;
            }
            // ------------------------------------

            const totalDist = calcTotalDistance(pathPoints).toFixed(0);
            
            const speedMpm = 300; 
            const totalMinutes = totalDist / speedMpm;
            let timeStr = "";
            
            if (totalMinutes < 60) {
                timeStr = `ç´„ ${Math.round(totalMinutes)} åˆ†é˜`;
            } else {
                const h = Math.floor(totalMinutes / 60);
                const m = Math.round(totalMinutes % 60);
                timeStr = `ç´„ ${h} å°æ™‚ ${m} åˆ†é˜`;
            }

            document.getElementById('statsBox').innerHTML = `
                <span class="text-indigo-300">æ¨¡å¼ï¼š${isFlowerPathMode ? 'ç¨®èŠ± (å«èµ·çµ‚é»)' : 'æ”¶æœ (ç›´é€£)'}</span><br>
                èŠ±æœµæ•¸: ${centers.length} | ç¯€é»æ•¸: ${pathPoints.length}<br>
                ç¸½é•·åº¦: ${totalDist} m<br>
                <span class="text-green-400 font-bold">${timeStr}</span> (ä»¥ 18km/h ä¼°ç®—)
            `;
        }

        function generatePathAlgorithm(centersList) {
            const path = [];
            for (let i = 0; i < centersList.length; i++) {
                const curr = centersList[i];
                let params = { ...globalParams };
                if (flowerOverrides[i]) params = { ...params, ...flowerOverrides[i] };
                const prev = (i === 0) ? centersList[centersList.length-1] : centersList[i-1];
                const next = (i === centersList.length - 1) ? centersList[0] : centersList[i+1];
                const angleFromPrev = getBearing(prev, curr);
                const angleToNext = getBearing(curr, next);
                const entryAngle = angleFromPrev - 180 + params.entryAngle;
                const p1 = getOffsetPoint(curr, FIXED_ALGO_DIST * FIXED_ENTRY_DIST, entryAngle);
                const apexAngle = angleToNext + params.apexAngle; 
                const p2 = getOffsetPoint(curr, FIXED_ALGO_DIST * FIXED_CROSS_FACTOR, apexAngle);
                const sideAngleCalc = angleToNext + params.sideAngle; 
                const p3 = getOffsetPoint(curr, FIXED_ALGO_DIST * FIXED_SIDE_DIST, sideAngleCalc);
                const exitAngleCalc = angleToNext + params.exitAngle;
                const p4 = getOffsetPoint(curr, FIXED_ALGO_DIST, exitAngleCalc);
                path.push(p1, p2, p3, p4);
            }
            return path;
        }

        function onParamChange(id, val) {
            const numVal = parseFloat(val);
            document.getElementById('val-' + id).innerText = numVal + 'Â°';
            if (selectedIndex === -1) {
                if (id === 'entryAng') globalParams.entryAngle = numVal;
                if (id === 'apexAng') globalParams.apexAngle = numVal;
                if (id === 'sideAng') globalParams.sideAngle = numVal;
                if (id === 'exitAng') globalParams.exitAngle = numVal;
            } else {
                if (!flowerOverrides[selectedIndex]) flowerOverrides[selectedIndex] = { ...globalParams };
                if (id === 'entryAng') flowerOverrides[selectedIndex].entryAngle = numVal;
                if (id === 'apexAng') flowerOverrides[selectedIndex].apexAngle = numVal;
                if (id === 'sideAng') flowerOverrides[selectedIndex].sideAngle = numVal;
                if (id === 'exitAng') flowerOverrides[selectedIndex].exitAngle = numVal;
            }
            updatePathData();
            draw();
        }

        function updateUIForMode() {
            const fab = document.getElementById('floating-actions');
            const fabReset = document.getElementById('fab-reset');
            const fabMirror = document.getElementById('fab-mirror');
            const redrawBtn = document.getElementById('quick-redraw-btn');
            const modeBtn = document.getElementById('quick-mode-btn');
            
            if (document.getElementById('sidebar').classList.contains('-translate-x-full')) {
                redrawBtn.classList.remove('hidden');
                modeBtn.classList.remove('hidden');
            } else {
                redrawBtn.classList.add('hidden');
                modeBtn.classList.add('hidden');
            }

            if (!isFlowerPathMode) {
                const indicator = document.getElementById('mode-indicator');
                const localBtns = document.getElementById('local-edit-btns');
                const swapHint = document.getElementById('swap-hint');
                
                indicator.innerText = "ç›´é€£æ¨¡å¼";
                indicator.className = "text-xs text-center p-2 rounded bg-indigo-900/50 text-indigo-200 border border-indigo-700/50";
                localBtns.classList.add('hidden');
                swapHint.classList.add('hidden');
                
                // ä¿®æ­£ 2: ç›´é€£æ¨¡å¼ä¸‹ä¹Ÿé¡¯ç¤ºæç¤ºæ¡†
                if (swapSourceIndex !== -1) {
                    document.getElementById('toast-message').classList.add('show');
                } else {
                    document.getElementById('toast-message').classList.remove('show');
                }
                
                if (selectedIndex !== -1) {
                    fab.classList.add('show');
                    fabReset.classList.add('hidden');
                    fabMirror.classList.add('hidden');
                } else {
                    fab.classList.remove('show');
                }
                return;
            }

            const indicator = document.getElementById('mode-indicator');
            const localBtns = document.getElementById('local-edit-btns');
            const swapHint = document.getElementById('swap-hint');
            
            let currentVals = { ...globalParams };
            if (selectedIndex !== -1 && flowerOverrides[selectedIndex]) {
                currentVals = { ...currentVals, ...flowerOverrides[selectedIndex] };
            }
            const normalize = (ang) => (ang % 360 + 360) % 360;

            document.getElementById('entryAngle').value = normalize(currentVals.entryAngle);
            document.getElementById('val-entryAng').innerText = Math.round(normalize(currentVals.entryAngle)) + 'Â°';
            document.getElementById('apexAngle').value = normalize(currentVals.apexAngle);
            document.getElementById('val-apexAng').innerText = Math.round(normalize(currentVals.apexAngle)) + 'Â°';
            document.getElementById('sideAngle').value = normalize(currentVals.sideAngle);
            document.getElementById('val-sideAng').innerText = Math.round(normalize(currentVals.sideAngle)) + 'Â°';
            document.getElementById('exitAngle').value = normalize(currentVals.exitAngle);
            document.getElementById('val-exitAng').innerText = Math.round(normalize(currentVals.exitAngle)) + 'Â°';

            if (selectedIndex === -1) {
                indicator.innerText = "å…¨åŸŸè¨­å®šæ¨¡å¼ (Global)";
                indicator.className = "text-xs text-center p-2 rounded bg-indigo-900/50 text-indigo-200 border border-indigo-700/50";
                localBtns.classList.add('hidden');
                swapHint.classList.add('hidden');
                document.getElementById('toast-message').classList.remove('show');
                fab.classList.remove('show'); 
            } else {
                indicator.innerText = `ç·¨è¼¯èŠ±æœµ #${selectedIndex + 1}`;
                indicator.className = "text-xs text-center p-2 rounded bg-purple-900/50 text-purple-200 border border-purple-700/50";
                localBtns.classList.remove('hidden');
                
                fab.classList.add('show');
                fabReset.classList.remove('hidden');
                fabMirror.classList.remove('hidden');
                
                if (swapSourceIndex !== -1) {
                    swapHint.classList.remove('hidden');
                    document.getElementById('toast-message').classList.add('show'); 
                } else {
                    swapHint.classList.add('hidden');
                    document.getElementById('toast-message').classList.remove('show');
                }
            }
        }

        function resetCurrentFlower() {
            if (selectedIndex !== -1) {
                delete flowerOverrides[selectedIndex];
                swapSourceIndex = -1; 
                updateUIForMode();
                updatePathData();
                draw();
            }
        }

        function mirrorCurrentFlower() {
            if (selectedIndex !== -1) {
                if (!flowerOverrides[selectedIndex]) flowerOverrides[selectedIndex] = { ...globalParams };
                const p = flowerOverrides[selectedIndex];
                p.entryAngle = (360 - p.entryAngle) % 360;
                p.apexAngle = (360 - p.apexAngle) % 360;
                p.sideAngle = (360 - p.sideAngle) % 360;
                p.exitAngle = (360 - p.exitAngle) % 360;
                updateUIForMode();
                updatePathData();
                draw();
            }
        }

        function initiateSwap() {
            if (selectedIndex !== -1) {
                swapSourceIndex = selectedIndex;
                updateUIForMode(); 
                draw(); 
                
                if (window.innerWidth <= 768) {
                    closeSidebar();
                }
            }
        }

        function deleteCurrentFlower() {
            if (selectedIndex === -1) return;

            // ç‚ºäº†é¿å…èª¤æŒ‰ï¼ŒåŠ å…¥ç¢ºèªå°è©±æ¡†
            if (!confirm("ç¢ºå®šè¦ç§»é™¤é€™å€‹é»ä½å—ï¼Ÿ")) return;

            // 1. å¾åº§æ¨™é™£åˆ—ä¸­ç§»é™¤
            centers.splice(selectedIndex, 1);

            // 2. è™•ç†åƒæ•¸è¦†å¯« (flowerOverrides) çš„ç´¢å¼•ä½ç§»
            // ç•¶åˆªé™¤ç¬¬ N å€‹é»ï¼ŒN ä¹‹å¾Œçš„æ‰€æœ‰åƒæ•¸éƒ½è¦å¾€å‰ç§»ä¸€æ ¼ (N+1 è®Šæˆ N)
            let newOverrides = {};
            Object.keys(flowerOverrides).forEach(key => {
                const idx = parseInt(key);
                if (idx < selectedIndex) {
                    // åœ¨åˆªé™¤é»ä¹‹å‰çš„è¨­å®šï¼Œä¿æŒä¸è®Š
                    newOverrides[idx] = flowerOverrides[idx];
                } else if (idx > selectedIndex) {
                    // åœ¨åˆªé™¤é»ä¹‹å¾Œçš„è¨­å®šï¼Œç´¢å¼•æ¸› 1
                    newOverrides[idx - 1] = flowerOverrides[idx];
                }
                // ç­‰æ–¼ selectedIndex çš„è¨­å®šå‰‡ç›´æ¥ä¸Ÿæ£„
            });
            flowerOverrides = newOverrides;

            // 3. é‡ç½®é¸å–ç‹€æ…‹
            selectedIndex = -1;
            swapSourceIndex = -1;

            // 4. é‡æ–°è¨ˆç®—å¹¾ä½•èˆ‡æ›´æ–°ç•«é¢
            checkAndFixGeometry(centers); // ç¢ºä¿å‰©é¤˜é»ä½çš„è§’åº¦é‚è¼¯æ­£ç¢º
            updatePathData();
            updateUIForMode();
            draw();
        }

        function draw() {
            ctx.fillStyle = '#F3F4F6'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (centers.length === 0) { drawGrid(); return; }

            const flowerR_m = 40;
            const brushD_m = 25;
            const brushR_m = brushD_m / 2;

            drawGrid();

            centers.forEach((p, idx) => {
                const sc = toScreen(p);
                const rPx = meterToPx(flowerR_m);
                const isSelected = (idx === selectedIndex);
                const isSwapSource = (idx === swapSourceIndex);

                ctx.beginPath();
                ctx.arc(sc.x, sc.y, rPx, 0, 2 * Math.PI);
                
                if (isSwapSource) {
                    ctx.fillStyle = 'rgba(245, 158, 11, 0.4)'; 
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                } else if (isSelected) { 
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.2)'; 
                    ctx.fill();
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 3;
                } else {
                    ctx.fillStyle = 'rgba(16, 185, 129, 0.1)'; 
                    ctx.fill();
                    ctx.strokeStyle = '#059669';
                    ctx.lineWidth = 2;
                }
                ctx.stroke();
            });

            if (isFlowerPathMode && pathPoints.length > 1) {
                ctx.fillStyle = 'rgba(239, 68, 68, 0.2)'; 
                const brushPx = meterToPx(brushR_m);
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p1 = toScreen(pathPoints[i]);
                    const p2 = toScreen(pathPoints[i+1]);
                    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    const steps = Math.ceil(dist / (brushPx * 0.5)); 
                    for (let j = 0; j <= steps; j++) {
                        const t = j / steps;
                        const lx = p1.x + (p2.x - p1.x) * t;
                        const ly = p1.y + (p2.y - p1.y) * t;
                        ctx.beginPath(); ctx.arc(lx, ly, brushPx, 0, 2 * Math.PI); ctx.fill();
                    }
                }
            }

            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.lineJoin = 'round';
            ctx.beginPath();
            pathPoints.forEach((p, i) => {
                const sc = toScreen(p);
                if (i === 0) ctx.moveTo(sc.x, sc.y); else ctx.lineTo(sc.x, sc.y);
            });
            ctx.stroke();

            if (isFlowerPathMode) {
                pathPoints.forEach((p, i) => {
                    const sc = toScreen(p);
                    
                    // [æ–°å¢] ç¹ªè£½èµ·é» (Index 0) - ç¶ è‰²æ–¹å¡Š S
                    if (i === 0) {
                        ctx.fillStyle = '#10b981'; // Green
                        ctx.fillRect(sc.x - 6, sc.y - 6, 12, 12);
                        ctx.fillStyle = 'white'; ctx.font = 'bold 10px Inter'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
                        ctx.fillText("S", sc.x, sc.y);
                        return;
                    }
                    
                    // [æ–°å¢] ç¹ªè£½çµ‚é» (Last Index) - ç´…è‰²æ–¹å¡Š E
                    if (i === pathPoints.length - 1) {
                        ctx.fillStyle = '#ef4444'; // Red
                        ctx.fillRect(sc.x - 6, sc.y - 6, 12, 12);
                        ctx.fillStyle = 'white'; ctx.font = 'bold 10px Inter'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
                        ctx.fillText("E", sc.x, sc.y);
                        return;
                    }

                    // ç¹ªè£½èŠ±æœµæ§åˆ¶é» (ä¸­é–“çš„é»)
                    // å› ç‚ºåŠ äº† startNode (index 0)ï¼Œæ‰€ä»¥èŠ±æœµçš„é»å¾ index 1 é–‹å§‹
                    // åæ¨æ˜¯ç¬¬å¹¾æœµèŠ±: (i - 1) / 4
                    const flowerIdx = Math.floor((i - 1) / 4);
                    
                    if (flowerIdx === selectedIndex) {
                        ctx.fillStyle = '#3b82f6'; 
                        ctx.beginPath(); ctx.arc(sc.x, sc.y, 5, 0, 2 * Math.PI); ctx.fill();
                        ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
                    }
                });
            } else {
                centers.forEach(p => {
                    const sc = toScreen(p);
                    ctx.fillStyle = '#ef4444'; 
                    ctx.beginPath(); ctx.arc(sc.x, sc.y, 4, 0, 2 * Math.PI); ctx.fill();
                });
            }

            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 12px Inter';
            centers.forEach((p, idx) => {
                const sc = toScreen(p);
                const isSelected = (idx === selectedIndex);
                const isSwapSource = (idx === swapSourceIndex);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath(); ctx.arc(sc.x - 8, sc.y - 8, 10, 0, 2 * Math.PI); ctx.fill();

                if (isSwapSource) ctx.fillStyle = '#f59e0b';
                else if (isSelected) ctx.fillStyle = '#a78bfa';
                else ctx.fillStyle = '#34d399';
                
                ctx.fillText(idx+1, sc.x - 8, sc.y - 8);
                ctx.fillStyle = '#ef4444'; ctx.fillRect(sc.x-2, sc.y-2, 4, 4);
            });
        }

        function drawGrid() {
            const gridPx = meterToPx(5);
            if (gridPx > 3) {
                const origin = centers.length > 0 ? toScreen(centers[0]) : {x: canvas.width/2 + offsetX, y: canvas.height/2 + offsetY};
                ctx.beginPath(); ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)'; ctx.lineWidth = 1;
                const startX = (origin.x % gridPx + gridPx) % gridPx;
                const startY = (origin.y % gridPx + gridPx) % gridPx;
                for (let x = startX; x < canvas.width; x += gridPx) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
                for (let y = startY; y < canvas.height; y += gridPx) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
                ctx.stroke();
            }
        }

        function generateGPX(type) {
            const routeName = document.getElementById('route-name').value.trim() || "æœªå‘½å";
            const count = centers.length;
            const modeName = isFlowerPathMode ? "ç¨®èŠ±" : "æ”¶æœ";
            const typeSuffix = type === 'Router' ? 'R' : 'J';
            const fileName = `${routeName}${modeName}${typeSuffix}(${count})`;
            const pointsToExport = isFlowerPathMode ? pathPoints : centers;
            if (pointsToExport.length === 0) { alert("æ²’æœ‰è·¯å¾‘è³‡æ–™ï¼"); return; }

            // [æ–°å¢] æº–å‚™è¦éš±è—çš„å°ˆæ¡ˆæ•¸æ“š (Project State)
            const appData = {
                ver: "1.0",
                type: "MushroomLabProject",
                centers: centers,          // åŸå§‹ä¸­å¿ƒé»
                overrides: flowerOverrides,// å€‹åˆ¥èŠ±æœµåƒæ•¸
                isFlower: isFlowerPathMode // ç•¶æ™‚æ˜¯å¦ç‚ºç¨®èŠ±æ¨¡å¼
            };
            // å°‡ç‰©ä»¶è½‰ç‚º JSON å­—ä¸²ï¼Œæ”¾åœ¨ desc æ¨™ç±¤ä¸­
            const serializedData = JSON.stringify(appData);

            let content = "";
            // åœ¨ GPX æ¨™é ­åŠ å…¥ desc æ¨™ç±¤å­˜æ”¾æ•¸æ“š
            const metadata = `<metadata><name>${fileName}</name><desc>${serializedData}</desc></metadata>`;

            if (type === 'Router') {
                const waypoints = pointsToExport.map(c => `  <wpt lat="${c.lat}" lon="${c.lon}"></wpt>`).join('\n');
                const trackpoints = pointsToExport.map(c => `    <trkpt lat="${c.lat}" lon="${c.lon}"></trkpt>`).join('\n');
                content = `<?xml version="1.0" encoding="utf-8" standalone="yes"?>\n<gpx version="1.1" creator="Mushroom Lab" xmlns="http://www.topografix.com/GPX/1/1">\n${metadata}\n${waypoints}\n<trk><name>${fileName}</name><trkseg>${trackpoints}</trkseg></trk></gpx>`;
            } else {
                const routepoints = pointsToExport.map(c => `<rtept lat="${c.lat}" lon="${c.lon}"/>`).join('');
                content = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?><gpx version="1.1" creator="Mushroom Lab">\n${metadata}\n<rte><name>${fileName}</name><number>0</number>${routepoints}</rte></gpx>`;
            }

            const blob = new Blob([content], { type: 'application/gpx+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `${fileName}.gpx`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function onCanvasClick(e) {
            const dx = e.clientX - clickStartX;
            const dy = e.clientY - clickStartY;
            if (Math.hypot(dx, dy) > 5) return; // åˆ¤å®šç‚ºé»æ“Š (æ”¾å¯¬åˆ¤å®šè‡³ 20px é‚è¼¯å·²åœ¨ handleStart)
            // é€™è£¡çš„ 5px æ˜¯é‡å° PC ç‰ˆçš„ä¿è­·ï¼Œæ‰‹æ©Ÿç‰ˆå·²åœ¨ handleStart è™•ç†

            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            let clickedIndex = -1;
            const hitRadius = Math.max(meterToPx(40), 20); // ç¢ºä¿æ‰‹æ©Ÿå¥½é»

            for (let i = centers.length - 1; i >= 0; i--) {
                const sc = toScreen(centers[i]);
                if (Math.hypot(mx - sc.x, my - sc.y) <= hitRadius) {
                    clickedIndex = i; break;
                }
            }

            if (swapSourceIndex !== -1) {
                if (clickedIndex !== -1 && clickedIndex !== swapSourceIndex) {
                    const temp = centers[swapSourceIndex];
                    centers[swapSourceIndex] = centers[clickedIndex];
                    centers[clickedIndex] = temp;
                    const tempOverride = flowerOverrides[swapSourceIndex];
                    flowerOverrides[swapSourceIndex] = flowerOverrides[clickedIndex];
                    flowerOverrides[clickedIndex] = tempOverride;
                    swapSourceIndex = -1;
                    selectedIndex = -1; 
                    checkAndFixGeometry(centers);
                    updatePathData();
                    updateUIForMode();
                    draw();
                    return;
                } else if (clickedIndex === -1) {
                    // Do not cancel swap on blank click
                    return;
                }
            }

            selectedIndex = clickedIndex;
            updateUIForMode();
            draw(); 
        }

        function onMouseDown(e) {
            clickStartX = e.clientX;
            clickStartY = e.clientY;
            handleStart(e.clientX, e.clientY);
        }
        function onMouseMove(e) { handleMove(e.clientX, e.clientY); }
        function onMouseUp() { handleEnd(); }
        function onTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                clickStartX = touch.clientX;
                clickStartY = touch.clientY;
                handleStart(touch.clientX, touch.clientY);
            }
        }
        function onTouchMove(e) {
            if (e.touches.length === 1 && (isDragging || isDraggingNode || isDraggingStart || isDraggingEnd)) {
                e.preventDefault(); 
                const touch = e.touches[0];
                handleMove(touch.clientX, touch.clientY);
            }
        }
        function onTouchEnd(e) { handleEnd(); }

        function handleStart(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;
            
            if (isFlowerPathMode && pathPoints.length > 2) {
                const nodeHitRadius = 20;
                
                // 1. æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ã€Œèµ·é»ã€ (Index 0)
                const startSc = toScreen(pathPoints[0]);
                if (Math.hypot(mx - startSc.x, my - startSc.y) <= nodeHitRadius) {
                    isDraggingStart = true;
                    isDragging = false;
                    return;
                }

                // 2. æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ã€Œçµ‚é»ã€ (Last Index)
                const endSc = toScreen(pathPoints[pathPoints.length - 1]);
                if (Math.hypot(mx - endSc.x, my - endSc.y) <= nodeHitRadius) {
                    isDraggingEnd = true;
                    isDragging = false;
                    return;
                }

                // 3. æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ã€ŒèŠ±æœµçµæ§‹é»ã€ (Index 1 ~ Length-2)
                // æ³¨æ„ï¼šå› ç‚ºåŠ äº†èµ·é»ï¼Œç¾åœ¨èŠ±æœµè·¯å¾‘åœ¨ pathPoints çš„ index å¾ 1 é–‹å§‹
                if (selectedIndex !== -1) {
                    // åŸæœ¬æ˜¯ selectedIndex * 4ï¼Œç¾åœ¨è¦ +1 (å› ç‚ºå‰é¢æœ‰å€‹ startNode)
                    const startNodeIdx = 1 + (selectedIndex * 4); 
                    
                    for (let i = 0; i < 4; i++) {
                        const nodeIdx = startNodeIdx + i;
                        if (nodeIdx < pathPoints.length - 1) { // æ‰£æ‰çµ‚é»
                            const p = pathPoints[nodeIdx];
                            const sc = toScreen(p);
                            if (Math.hypot(mx - sc.x, my - sc.y) <= nodeHitRadius) {
                                isDraggingNode = true; 
                                draggingNodeIndex = i; // é€™è£¡ä¿æŒ i (0~3) ä»£è¡¨èŠ±çš„å››å€‹è§’
                                isDragging = false; 
                                return;
                            }
                        }
                    }
                }
            }
            isDragging = true; lastMouseX = clientX; lastMouseY = clientY;
        }

        function handleMove(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;

            // [æ–°å¢] æ‹–æ›³èµ·é»
            if (isDraggingStart) {
                startNode = screenToLatLon(mx, my);
                updatePathData(); // æ›´æ–° pathPoints é™£åˆ—
                draw();
                return;
            }

            // [æ–°å¢] æ‹–æ›³çµ‚é»
            if (isDraggingEnd) {
                endNode = screenToLatLon(mx, my);
                updatePathData(); // æ›´æ–° pathPoints é™£åˆ—
                draw();
                return;
            }

            // èª¿æ•´èŠ±æœµè§’åº¦ (é‚è¼¯ä¸è®Šï¼Œä½†å› ç‚º pathPoints çµæ§‹æ”¹è®Šï¼Œæˆ‘å€‘ä¸éœ€è¦å‹•é€™è£¡ï¼Œ
            // å› ç‚º draggingNodeIndex å„²å­˜çš„æ˜¯ 0~3ï¼Œä»£è¡¨èŠ±çš„å››å€‹è§’è½ï¼Œé€™é‚è¼¯æ˜¯é€šç”¨çš„)
            if (isDraggingNode && selectedIndex !== -1) {
                const center = centers[selectedIndex];
                const centerSc = toScreen(center);
                const dy = centerSc.y - my; 
                const dx = mx - centerSc.x;
                let mouseAngle = Math.atan2(dx, dy) * (180 / Math.PI);
                const prev = (selectedIndex === 0) ? centers[centers.length-1] : centers[selectedIndex-1];
                const next = (selectedIndex === centers.length - 1) ? centers[0] : centers[selectedIndex+1];
                const angleFromPrev = getBearing(prev, center);
                const angleToNext = getBearing(center, next);
                let newVal;
                const normalize = (ang) => (ang % 360 + 360) % 360;
                
                if (draggingNodeIndex === 0) { 
                    newVal = normalize(mouseAngle - (angleFromPrev - 180));
                    onParamChange('entryAng', newVal);
                } else if (draggingNodeIndex === 1) { 
                    newVal = normalize(mouseAngle - angleToNext);
                    onParamChange('apexAng', newVal);
                } else if (draggingNodeIndex === 2) { 
                    newVal = normalize(mouseAngle - angleToNext);
                    onParamChange('sideAng', newVal);
                } else if (draggingNodeIndex === 3) { 
                    newVal = normalize(mouseAngle - angleToNext);
                    onParamChange('exitAng', newVal);
                }
                return;
            }

            // æ‹–æ›³åœ°åœ–
            if (isDragging) {
                const dx = clientX - lastMouseX;
                const dy = clientY - lastMouseY;
                offsetX += dx; offsetY += dy;
                lastMouseX = clientX; lastMouseY = clientY;
                draw();
            }
        }

        function handleEnd() { 
            isDragging = false; 
            isDraggingNode = false; 
            isDraggingStart = false; 
            isDraggingEnd = false; 
            draggingNodeIndex = -1; 
        }
        
        function onWheel(e) { e.preventDefault(); const factor = e.deltaY > 0 ? 0.9 : 1.1; scale *= factor; draw(); }

        function parseTextToPoints(text) {
            if (!text) return [];
            return text.trim().split('\n').map(line => {
                const parts = line.replace(/[^\d\.\-\,\s]/g, '').trim().split(/[,\s]+/);
                if (parts.length >= 2) {
                    const lat = parseFloat(parts[0]);
                    const lon = parseFloat(parts[1]);
                    if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90) return { lat, lon };
                }
                return null;
            }).filter(p => p !== null);
        }
        function getDistanceMeters(p1, p2) {
            const dy = (p1.lat - p2.lat) * METERS_PER_DEGREE;
            const dx = (p1.lon - p2.lon) * METERS_PER_DEGREE;
            return Math.sqrt(dx*dx + dy*dy);
        }
        function getBearing(p1, p2) {
            const dLon = p2.lon - p1.lon; const dLat = p2.lat - p1.lat;
            return (Math.atan2(dLon, dLat) * 180 / Math.PI + 360) % 360;
        }
        function getOffsetPoint(p, distMeters, bearingDeg) {
            const distDeg = distMeters / METERS_PER_DEGREE;
            const rad = bearingDeg * (Math.PI / 180);
            return { lat: p.lat + distDeg * Math.cos(rad), lon: p.lon + distDeg * Math.sin(rad) };
        }
        function toScreen(p) {
            const base = centers.length > 0 ? centers[0] : {lat:0, lon:0}; 
            const dx = (p.lon - base.lon) * METERS_PER_DEGREE;
            const dy = (p.lat - base.lat) * METERS_PER_DEGREE;
            const cx = canvas.width / 2; const cy = canvas.height / 2;
            return { x: cx + dx * (scale / 100) + offsetX, y: cy - dy * (scale / 100) + offsetY };
        }
        function meterToPx(m) { return m * (scale / 100); }
        function centerMap() { offsetX = 0; offsetY = 0; scale = 300; draw(); }
        function resetView() { centerMap(); }
        function zoomStep(factor) { scale *= factor; draw(); }
        function fitToScreen() {
            if (centers.length === 0) { centerMap(); return; }
            let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
            centers.forEach(p => {
                if (p.lat < minLat) minLat = p.lat; if (p.lat > maxLat) maxLat = p.lat;
                if (p.lon < minLon) minLon = p.lon; if (p.lon > maxLon) maxLon = p.lon;
            });
            const padding = 50 / METERS_PER_DEGREE;
            minLat -= padding; maxLat += padding; minLon -= padding; maxLon += padding;
            const latRange = maxLat - minLat; const lonRange = maxLon - minLon;
            const scaleY = (canvas.height) / (latRange * METERS_PER_DEGREE) * 100;
            const scaleX = (canvas.width) / (lonRange * METERS_PER_DEGREE) * 100;
            scale = Math.min(scaleX, scaleY);
            offsetX = 0; offsetY = 0;
            const mapCenterLat = (minLat + maxLat) / 2; const mapCenterLon = (minLon + maxLon) / 2;
            const currentCenterScreen = toScreen({lat: mapCenterLat, lon: mapCenterLon});
            offsetX = (canvas.width / 2) - currentCenterScreen.x;
            offsetY = (canvas.height / 2) - currentCenterScreen.y;
            draw();
        }
        function calcTotalDistance(pts) {
            let d = 0;
            for(let i=0; i<pts.length-1; i++) {
                const dy = (pts[i+1].lat - pts[i].lat) * METERS_PER_DEGREE;
                const dx = (pts[i+1].lon - pts[i].lon) * METERS_PER_DEGREE;
                d += Math.sqrt(dx*dx + dy*dy);
            }
            return d;
        }
        function toggleSidebar() {
            const sb = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            if (sb.classList.contains('-translate-x-full')) {
                sb.classList.remove('-translate-x-full');
                overlay.classList.remove('hidden');
                document.getElementById('quick-redraw-btn').classList.add('hidden'); // sidebar open -> hide redraw
                document.getElementById('quick-mode-btn').classList.add('hidden'); // sidebar open -> hide mode toggle
            } else {
                sb.classList.add('-translate-x-full');
                overlay.classList.add('hidden');
                document.getElementById('quick-redraw-btn').classList.remove('hidden'); // sidebar closed -> show redraw
                document.getElementById('quick-mode-btn').classList.remove('hidden'); // sidebar closed -> show mode toggle
            }
        }
        function closeSidebar() {
            document.getElementById('sidebar').classList.add('-translate-x-full');
            document.getElementById('sidebar-overlay').classList.add('hidden');
            document.getElementById('quick-redraw-btn').classList.remove('hidden'); // sidebar closed -> show redraw
            document.getElementById('quick-mode-btn').classList.remove('hidden'); // sidebar closed -> show mode toggle
        }
    </script>
</body>
</html>